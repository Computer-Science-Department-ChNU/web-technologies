<!DOCTYPE html>
<html lang="uk">
<head>
    <title>Тема 19. Асинхронний код. Promise.</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="../../../core/styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }
    </style>
</head>
<body class="shower list">

<header class="caption">
    <h1>Тема 19. Асинхронний код. Promise.</h1>
</header>

<section class="slide">
    <h2>Тема 19. Асинхронний код. Promise.</h2>
    <ol>
        <li>Синхронний та асинхронний код</li>
        <li>Функції зворотного виклику для асинхронного коду</li>
        <li>Promise</li>
        <li>Promise API</li>
    </ol>
</section>

<section class="slide">
    <h2>Синхронний код</h2>
    <p><b>Синхронний код </b>- код, що виконується послідовно, кожна операція очікує на завершення
        попередньої.</p>
    <img src="images/1.png" alt="" width="100%">
</section>

<section class="slide">
    <h2>Синхронний код</h2>
    <p>Синхронне виконання може призвести до наступних проблем:</p>
    <ul>
        <li>Блокування UI</li>
        <li>Затримки та підвисання</li>
        <li>Низька продуктивність додатків</li>
        <li>Складність в управлінні потоками</li>
        <li>Відсутність можливості використання асинхронних ресурсів</li>
    </ul>
</section>

<section class="slide">
    <h2>Синхронний код та Call Stack</h2>
    <img src="images/3.png" alt="" width="100%">
</section>

<section class="slide">
    <h2>Асинхронність</h2>
    <p>
        <b>Асинхронність</b> — це процес обробки введення/виводу, що дозволяє продовжити обробку
        інших завдань, не чекаючи завершення попереднього завдання.
    </p>
    <img src="images/4.png" alt="" width="70%">
</section>

<section class="slide">
    <h2>Асинхронний код</h2>
    <p>
        <b>Асинхронний код</b> – код, що виконується паралельно, а не послідовно. У більшості випадків
        асинхронне виконання коду передбачає виділення нових ресурсів для виконання асинхронних
        викликів - потоків.
    </p>
    <img src="images/2.png" alt="" width="750">
</section>

<section class="slide">
    <h2>Асинхронний код та Call Stack</h2>
    <img src="images/5.png" alt="" width="100%">
</section>

<section class="slide">
    <h2>Асинхронний код</h2>
    <ul>
        <li>Швидша робота додатків</li>
        <li>Легке масштабування</li>
        <li>Збереження інтерфейсу користувача</li>
        <li>Уникнення падіння додатку</li>
        <li>Управління помилками</li>
    </ul>
</section>

<section class="slide">
    <h2>Організація асинхронного коду</h2>
    <p>
        <b>Асинхронний код</b> — код, в якому операції можуть виконуватися паралельно. Якщо
        операція запускається асинхронно, наступна операція може запуститися відразу після
        операції, запущеної асинхронно, але оскільки асинхронна операція виконується
        паралельно з іншими, необхідний спосіб обробити результат асинхронної операції у
        майбутньому.
    </p>
    <b>Варіанти організації асинхронного коду:</b>
    <ul>
        <li>Callback (функція зворотного виклику)</li>
        <li>Promise</li>
        <li>Шаблон Observer</li>
        <li>Promise API</li>
    </ul>
</section>

<section class="slide">
    <h2>Організація асинхронного коду</h2>
    <pre>
        <code>function callback(result) {</code>
          <code>...</code>
        <code>}</code>
        <code>download(callback);</code>
    </pre>
    <pre>
        <code>let promise = download();</code>
        <code>promise.then(callback);</code>
    </pre>
    <pre>
        <code>let observable = download();</code>
        <code>observable.subscribe(callback);</code>
    </pre>
</section>

<section class="slide">
    <h2>Callback</h2>
    <p>
        <b>Callback (колбек, функція зворотного виклику)</b> - функція, яка викликається у відповідь на вчинення деякої
        події.
    </p>
    <b>Загалом, подією може бути що завгодно:</b>
    <ul>
        <li>відповідь від сервера;</li>
        <li>завершення якогось тривалого обчислювального завдання;</li>
        <li>отримання доступу до якихось API пристрою, на якому виконується код</li>
    </ul>
    <p>Таким чином колбек - це перший спосіб обробити будь-яку асинхронну дію.</p>
    <p>Однак у колбеків є неприємний мінус, так зване пекло колбеків (callback hell).</p>
</section>

<section class="slide">
    <h2>Callback</h2>
    <p>Навіть якщо вам не потрібно працювати з сервером, досить високі шанси зіткнутися з функціями зворотного
        виклику.</p>
    <p>forEach, every, some, reduce, filter, або функції сортування sort, або методу addEventListener (другий параметр
        приймає функцію, яку буде викликано в разі настання події)</p>
    <p>Аналогічно з установкою обробників подій. Щоразу, коли ви підписуєтеся на подію за допомогою addEventListener,
        через її другий параметр ви визначаєте функцію зворотного виклику, яка спрацює під час настання події. У світі
        JavaScript колбеки всюди.</p>
</section>

<section class="slide">
    <h2>Callback</h2>
    <img src="images/6.png" alt="" width="100%">
</section>

<section class="slide">
    <h2>Callback, setTimeout, Event loop</h2>
    <p>
        Функція setTimeout() не є
        частиною JavaScript-движка, це по суті <b>Web API</b>, включене в середовище браузера як додаткова
        функціональність.
    </p>
    <p>Ця додаткова функціональність (Web API) бере на себе роботу з таймерами, інтервалами, обробниками подій. Тобто
        коли ми реєструємо обробник кліка на кнопку - він потрапляє в оточення Web API. Саме воно знає, коли обробник
        потрібно викликати.</p>
    <p>Управління тим, як мають викликатися функції Web API, бере на себе цикл подій <b>(Event loop)</b>.</p>
    <p>Цикл подій відповідає за виконання коду, збір та обробку подій і виконання підзадач із черги.</p>
</section>

<section class="slide">
    <h2>Callback, setTimeout, Event loop</h2>
    <div style="font-size: 19px;">
        <p>
            Зауважте, що стек викликів і черга завдань називаються саме стеком і чергою. Тому що виклики зі стека
            працюють
            за принципом "останній зайшов, перший вийшов" (LIFO: last in, first out), а в черзі - за принципом "перший
            зайшов, перший вийшов" (FIFO: first in, first out).
        </p>
        <p>
            Черга - структура даних, у якій елементи впорядковані так, що перший елемент, який потрапив у чергу, залишає
            її
            першим.
        </p>
        <p>Таким чином цикл подій працює з асинхронним кодом - тобто таким, що виконується не построково.</p>
        <p><a href="http://latentflip.com/loupe/" target="_blank">http://latentflip.com/loupe/</a> - інструмент Loupe
            Филипа
            Робертса</p>
        <p style="color: #cc0000">Приклад 001 - 007 з директорії js/1-19-asynchronous-code-promises/examples</p>
    </div>
</section>

<section class="slide">
    <h2>Promise</h2>
    <p>
        <b>Promise</b> – об'єкт, який зберігає кінцевий результат асинхронної операції. Promise – є
        значенням, яке ще не існує. <i>Daniel P. Friedman та David Wise запропонували термін Promise
        у 1976 році.</i>
    </p>
    <b>Можливі стани об'єкта promise:</b>
    <ul>
        <li>Fulfilled — асинхронна операція успішно завершена</li>
        <li>Rejected — асинхронна операція закінчена з помилкою</li>
        <li>Pending — асинхронна операція ще виконується</li>
    </ul>
    <p>Promise, який перейшов у стан Fulfilled або Rejected, називається Settled</p>
</section>

<section class="slide">
    <h2>Promise</h2>
    <p>
        Для визначення дії, яка буде запускатися у випадку, якщо Promise перейшов в один із
        станів, використовується функція then(f1, f2) де f1 — функція зворотного виклику, яка
        спрацює, якщо проміс перейшов у стан Fulfilled, f2 — функція зворотного виклику, яка
        спрацює при переході у Rejected.
    </p>
    <p><b>p.then(f, r)</b>– якщо p у стані fulfilled функція f буде
        викликана.</p>
    <p><b>p.then(f, r)</b> – якщо p у стані rejected функція r буде
        викликана.</p>
    <p>В інших випадках р у стані pending.</p>
    <p style="color: #cc0000">Приклад 008 з директорії js/1-19-asynchronous-code-promises/examples</p>
</section>

<section class="slide">
    <h2>Promise</h2>
    <p>
        Недоліком організації асинхронного коду через callback функції — необхідність
        використовувати додаткові параметри для всіх асинхронних операцій та складність
        управління певних послідовностей виклику асинхронних операцій через необхідність
        створювати вкладені функції зворотного виклику та погіршувати читабельність коду.
    </p>
    <p>При використанні промісів можна будувати ланцюжки промісів. Немає потреби
        організовувати вкладеність коду, що полегшує розуміння асинхронного коду.</p>
    <p style="color: #cc0000">Приклад 009 - 012 з директорії js/1-19-asynchronous-code-promises/examples</p>
</section>

<section class="slide">
    <h2>Основні методи промісів: then, catch, finally</h2>
    <img src="images/7.png" alt="" width="100%">
    <p style="color: #cc0000">Приклад 010 - 012 з директорії js/1-19-asynchronous-code-promises/examples</p>
</section>

<section class="slide">
    <h2>Promise API</h2>
    <p><b>Promise.all(масив)</b> — метод, який дозволяє дочекатися завершення всіх промісів,
        вказаних у параметрі та виконати дію після них.</p>
    <p><b>Promise.race(масив)</b> — метод, який дочекається завершення одного з промісів, вказаних у
        масиві та проігнорує інші.</p>
    <p><b>Promise.allSettled(масив)</b> — очікується, коли всі проміси отримають стан і повертає
        новий проміс, який як параметр отримує масив з даними про стани та значення settled
        промісів.</p>
    <p style="color: #cc0000">Приклад 013 з директорії js/1-19-asynchronous-code-promises/examples</p>
</section>

<section class="slide">
    <h2>Promise (недоліки)</h2>
    <p>Проміси виявилися зручними, і з'явився навіть такий термін як "промісифікація" - коли асинхронну функціональність
        на колбеках перетворювали на проміси.</p>
    <b>У них є кілька недоліків:</b>
    <ul>
        <li>Код не такий лаконічний, як міг бути.</li>
        <li>Стек помилок може містити в собі then.then.then.then.then.then....</li>
        <li>Вкладені умови сильно збільшують кількість коду і погіршують читабельність.</li>
    </ul>
    <p>
        Для вирішення цих проблем придумали асинхронні функції, які повертають проміси. Існує спеціальний синтаксис для
        більш зручної роботи з промісами, який називається “async/await”..
    </p>
</section>

<section class="slide">
    <h2>async/await</h2>
    <div style="font-size: 17px;">
        <p>Асинхронна функція позначається спеціальним ключовим словом async.</p>
        <p>У середині асинхронних функцій можна викликати інші асинхронні функції, без будь-яких then() або колбеків, за
            допомогою ключового слова await.</p>
        <p>Додане перед визначенням функції ключове слово async робить функцію асинхронною. Повернуте значення такої
            функції
            автоматично обертається в Promise</p>
        <p>Асинхронні функції потрібні для виконання асинхронних операцій: роботи з API, базами даних, читання файлів
            тощо.</p>
        <p>Асинхронні операції виконуються не одразу: код надіслав запит до API і чекає, поки сервер надішле відповідь.
            Ключове слово await використовується, щоб дочекатися виконання асинхронної операції.</p>
        <p style="color: #cc0000">Приклад 014, 015 з директорії js/1-19-asynchronous-code-promises/examples</p>
    </div>
</section>

<section class="slide">
    <h2>Контрольні питання</h2>
    <ol style="font-size: 16px;">
        <li>У чому різниця синхронного та асинхронного коду?</li>
        <li>Напишіть принцип використання функцій зворотного дзвінка для організації
            асинхронного коду.
        </li>
        <li>У чому нестача функцій зворотного дзвінка під час роботи з асинхронним кодом?</li>
        <li>Що таке Promise?</li>
        <li>Назвіть основні методи Promise</li>
        <li>У чому різниця Promise.all та Promise.race?</li>
        <li>Як можна обробити помилку в асинхронному коді організованому через Promise</li>
        <li>В чому різниця між async/await та Promise?</li>
        <li>Які є блоки для роботи з async/awit?</li>
        <li>Для чого потрібен блок try в async функціях?</li>
        <li>Що робить блок finally в async функції?</li>
        <li>Що повертає async функція в результаті виконання?</li>
    </ol>
</section>

<section class="slide">
    <h2 class="shout">Дякую за увагу!</h2>
</section>

<div class="progress"></div>

<script src="../../../core/shower.js"></script>
</body>
</html>

